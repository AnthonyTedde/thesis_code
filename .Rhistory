probI <- (3e29 - 3e28)/2^n
# Check:
length(X[X > 3e28/2^n & X < 3e29/2^n]) / length(X)
library(ggplot2)
a <- 0
b <- 4
max_length <- (b-a) / 100
max_length
?seq
seq(a, b, by = max_length)
max(c(1, 2,3))
?max
optimize(x^2, lower = 0, upper = 0.4, maximum = T)
optimize(function(x) x^2, lower = 0, upper = 0.4, maximum = T)
0.4^2
0.2^2
0.3999^2
optimise(function(x) x^2, lower = 0, upper = 0.4, maximum = T)
x_square <- function(x) x^2
optimise(x_square, lower = partition_point[1],
upper = partition_point[2],
maximum = T)
partition_tmp <- 100
max_length <- (b-a) / partition_tmp
partition_point <- seq(a, b, by = max_length)
partition_point
x_square <- function(x) x^2
optimise(x_square, lower = partition_point[1],
upper = partition_point[2],
maximum = T)
optimise(x_square, lower = partition_point[1],
upper = partition_point[2],
maximum = T)$objective
1:length(partition_point)
for(i in 2:length(partition_point))
optimise(x_square, lower = partition_point[i-1],
upper = partition_point[i],
maximum = T)$objective
optimise(x_square, lower = partition_point[i-1],
upper = partition_point[i],
maximum = T)$objective
optimise(x_square, lower = partition_point[i-1],
upper = partition_point[i],
maximum = T)$objective
optimise(x_square, lower = partition_point[i-1],
upper = partition_point[i],
maximum = T)$objective
i
for(i in 2:length(partition_point))
optimise(x_square, lower = partition_point[i-1],
upper = partition_point[i],
maximum = T)$objective
a <- for(i in 2:length(partition_point))
optimise(x_square, lower = partition_point[i-1],
upper = partition_point[i],
maximum = T)$objective
a
for(i in 2:length(partition_point))
a[i-1] <- optimise(x_square, lower = partition_point[i-1],
upper = partition_point[i],
maximum = T)$objective
a
a*partition_point
length(a)
length(partition_point)
a*max_length
sum(a*max_length)
4^3
/3
64/3
sum(upper * max_length)
x_square <- function(x) x^2
for(i in 2:length(partition_point))
upper[i-1] <- optimise(x_square, lower = partition_point[i-1],
upper = partition_point[i],
maximum = T)$objective
for(i in 2:length(partition_point))
lower[i-1] <- optimise(x_square, lower = partition_point[i-1],
upper = partition_point[i],
maximum = T)$objective
upper <- lower <- vector()
for(i in 2:length(partition_point))
upper[i-1] <- optimise(x_square, lower = partition_point[i-1],
upper = partition_point[i],
maximum = T)$objective
for(i in 2:length(partition_point))
lower[i-1] <- optimise(x_square, lower = partition_point[i-1],
upper = partition_point[i],
maximum = T)$objective
sum(upper * max_length)
4^3
/3
64/3
sum(lower * max_length)
for(i in 2:length(partition_point))
lower[i-1] <- optimise(x_square, lower = partition_point[i-1],
upper = partition_point[i])$objective
sum(lower * max_length)
# By consequence the Upper Riemann integral is:
upper_riemann_sum <- sum(upper * max_length)
# And the lower:
lower_riemann_sum <- sum(lower * max_length)
c(1,0)
list(c(1,0))
k <- 20
Y <- expand.grid(
rep(list(c(1,0)), n)
)
Y[10,10]
Y[10,]
Y[, 10
]
Y[,1]
Y[,2]
Y[,3]
Y[,1:3]
Y <- t(apply(Y, MARGIN = 1,FUN = function(x) x/2^(1:n)))
X <- sort(rowSums(Y), decreasing = T)
head(X)
X[1]
X[length(X)]
Y[1:3, 1:3]
Y[1:10, 1:10]
period <- c(0, 1)
S0      <- 4
k       <- 5
u       <- 2
r       <- 1/4
p       <- 0.5
X0      <- 1.20
delta0  <- 0.5
stockPricePath_f = function(i, j){
ifelse(j >= i,
u ^(j - i) * d^(i - 1) * S0,
NA_integer_)
}
stockPricePath <- outer(period + 1,
period + 1,
stockPricePath_f)
stockPricePath_f = function(i, j){
ifelse(j >= i,
u ^(j - i) * d^(i - 1) * S0,
NA_integer_)
}
stockPricePath <- outer(period + 1,
period + 1,
stockPricePath_f)
d <- 1/u
stockPricePath <- outer(period + 1,
period + 1,
stockPricePath_f)
stockPricePath
k <- 3
Y <- expand.grid(
rep(list(c(1,0)), k)
)
Y
n <- 20
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^(1:n)))
X <- sort(rowSums(Y), decreasing = T)
distrib_X <- data.frame('X' = X,
'P' = 1/length(X),
'F' = seq(1/length(X), 1, by = 1/length(X)))
ggplot(distrib_X, aes(X, F)) +
geom_point()
library(ggplot2)
ggplot(distrib_X, aes(X, F)) +
geom_point()
k <- 3
Y <- expand.grid(
rep(list(c(1,0)), k)
)
Y <- expand.grid(
rep(list(c(1,0)), k)
)
Y
dbinom(c(0, .25, .5.75)
dbinom(c(0, .25, .5, .75, 1), 5, .5)
qbinom(seq(0,1, by=0.05), 3, .5)
qbinom(seq(0,1, by=0.05), 1, .5)
library(ggplot2)
W <- seq(from = 0,
to = 1,
by = .0001)
W
p <- 1/2
q <- 1 - p
expe <- 100000
n <- 100
n <- 20
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^(1:n)))
X <- sort(rowSums(Y), decreasing = T)
distrib_X <- data.frame('X' = X,
'P' = 1/length(X),
'F' = seq(1/length(X), 1, by = 1/length(X)))
prob_X <- 1/length(X)
sum(X * prob_X)
ggplot(distrib_X, aes(X, F)) +
geom_point()
k = .25 * 2^n
m = .75 * 2^n
Y = list()
for(i in 1:expe){
Y[[i]] <- rbinom(n = n,
size = 1,
prob = p)
}
Y
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y[10,10]
Y[1:10,1:10]
k <- 3
Y <- expand.grid(
rep(list(c(1,0)), k)
)
Y
H <- rowSums(Y)
H
H/3
1/8 * sum(H/3)
EH3 = 1/8 * sum(H/3)
EH3
k <- 20
Y <- expand.grid(
rep(list(c(1,0)), k)
)
H <- rowSums(Y)
H
EH3 = 1/(2^k) * sum(H/k)
EH3
H/k
EH3 = 1/(2^k) * sum(H/k)
k <- 30
Y <- expand.grid(
rep(list(c(1,0)), k)
)
H <- rowSums(Y)
EH3 = 1/(2^k) * sum(H/k)
H <- rowSums(Y)
EH3 = 1/(2^k) * sum(H/k)
EH3
k <- 20
Y <- expand.grid(
rep(list(c(1,0)), k)
)
H <- rowSums(Y)
EH3 = 1/(2^k) * sum(H/k)
EH3
norm()
?norm
dnorm(c(-1, 1))
dnorm(c(-1, 1, 0))
dnorm(seq(-4,4,by = 0.01))
w <- dnorm(seq(-4,4,by = 0.01))
plot(w)
s <- seq(-4, 4, by = 0.01)
w <- dnorm(s)
cbind(s, w)
dist <- cbind(s, w)
library(ggplot2)
dist <- cbind(s, w)
ggplot(dist, aes(w, s))
dist <- as.dataframe(cbind(s, w))
dist <- as.data.frame(cbind(s, w))
ggplot(dist, aes(w, s))
ggplot(dist, aes(w, s)) + geom_line()
ggplot(dist, aes(s, w)) + geom_line()
pnorm(c(1,1))
pnorm(c(4))
pnorm(c(5))
pnorm(c(1)) - pnorm(-1)
qnrom(0.68)
qnorm(0.68)
pnrom(0)
pnorm(0)
qnorm(0.5)
integral(dnorm, -9,0)
pnorm(1) - pnorm(-1)
methods("t.test")
getS3method("t.test.default*")
getS3method("t.test.default")
getS3method("mean")
getS3method("mean", 'Date')
getS3method("mean", 'Dat')
getS3method("mean", 'Date')
a <- sturcture(list(), class = c('a', 'b'))
a <- structure(list(), class = c('a', 'b'))
class(a)
inherits(a, 'a')
inherits(a, 'b')
inherits(a, c('a', 'b'))
inherits(a, LETTERS[1:2])
inherits(a, lower(LETTERS[1:2]))
lower.tri(LETTERS)
LETTERS
lower(LETTERS)
?lower.tri
inherits(a, str_to_lower(LETTERS[1:2]))
library(stringr)
inherits(a, str_to_lower(LETTERS[1:2]))
class(glm())
f.a <- function(x) "class a"
a <- structure(list(), class = 'a')
f(a)
f.a(a)
f <- function(x) <- UseMethod("f")
f <- function(x) UseMethod("f")
f(a)
b <- structure(list(), class = "b")
f(b)
f.a(b)
formals(mean)
mean
mean.a <- function(x, ...) "a"
mean(a)
mean.a <- function() "a"
mean.a <- function() "b"
mean(a)
f.b <- function() "class b"
f(b)
f.b <- function(x) "class b"
f(b)
paste0("generic", ".", c(class(x), "default"))
paste0("generic", ".", c(class(a), "default"))
f
methods(f)
f.default <- function(x) 'Unknown class'
c <- structure(list(), class = 'c')
f(c)
f(b)
?NextMethod
seq(4, 32, by = 4)
seq(4, 32, 4)
?seq
outer(1:3, 1:3, paste(sep = ','))
outer(1:3, 1:3, paste,sep = ',')
s = 4
n = 3
outer(0:n, 0:3, paste,sep = ',')
factor <- 2
outer(0:n, 0:3, function(i, j){s * factor ^ i})
outer(0:n, 0:3, function(i, j){s * factor ^ j})
outer(0:n, 0:3, function(i, j){s * factor ^ j / (4 ^ j)})
outer(0:n, 0:3, function(i, j){s * factor ^ j / (4 ^ i)})
cpt <- function(i, j){
s * factor ^ j / (4 ^ i)
}
outer(0:n, 0:3, cpt(i,j) )
cpt <- function(i, j){
s * factor ^ j / (4 ^ i)
}
outer(0:n, 0:3, cpt(i,j) )
cpt
cpt(0:n, 0:n)
outer(0:n, 0:3, cpt )
cpt <- function(i, j){
if(i<=j){
s * factor ^ j / (4 ^ i)
}else NA
}
outer(0:n, 0:3, cpt )
cpt <- function(i, j){
ifelse(i<=j, s * factor ^ j / (4 ^ i), NA)
}
outer(0:n, 0:3, cpt )
factor <- 3
cpt <- function(i, j){
ifelse(i<=j, s * factor ^ j / (4 ^ i), NA)
}
outer(0:n, 0:n, cpt )
factor <- 3
seq(4, 32, by = 4)
cpt <- function(i, j){
ifelse(i<=j, s * factor ^ j / (factor ^ i), NA)
}
outer(0:n, 0:n, cpt )
cpt <- function(i, j){
ifelse(i<=j, s * 2 ^ j / (4 ^ i), NA)
}
outer(0:n, 0:n, cpt )
binomialAssetPrice <- function(s = 4, n = 3){
# matrix (n+1) * (n+1) due to S0
cpt <- function(i, j){
ifelse(i<=j, s * 2 ^ j / (4 ^ i), NA)
}
outer(0:n, 0:n, cpt )
}
binomialAssetPrice(5)
binomialAssetPrice(4, 3)
S <- binomialAssetPrice(4, 3)
library(ggplot2)
p <- 1/2
q <- 1 - p
figure <- paste(getwd(),'StochasticCalculusForFinanceVol2',
'Chapter3',
'figure',
sep = '/')
figure
<- 3000
as
k <- 3000
asize <- 75000
X <- sample(x = c(-1, 1),
size = k,
replace = T,
prob = c(p, q)
)
X
Mk <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
Mk
Mk <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
file <- paste(figure, 'EmpiricalSymmetricRandomWalkSample.pdf', sep = '/')
pdf(file = file)
plot(Mk,
type = 'l')
dev.off()
file <- paste(figure, 'EmpiricalSymmetricRandomWalkSeveral.pdf', sep = '/')
dev.off()
file <- paste(figure, 'EmpiricalSymmetricRandomWalkSeveral.pdf', sep = '/')
randomWalkGenerator <- function(step = 3000,
prob = c(0.5, 0.5),
n = 1){
X <- sample(x = c(-1, 1),
size = k,
replace = T,
prob = c(p, q)
)
Mk <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
}
randomWalkGenerator()
randomWalkGenerator <- function(step = 3000,
prob = c(0.5, 0.5),
n = 1){
X <- sample(x = c(-1, 1),
size = k,
replace = T,
prob = c(p, q)
)
(Mk <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
)
}
randomWalkGenerator()
lapply(1:4, sample(x = c(-1, 1), size = k, replace = T, prob = c(0.5, .5)))
rep(c(-1, 1))
rep(c(-1, 1), 5)
rep(list(-1, 1), 5)
rep(list(c(-1, 1)), 5)
n = 5
x <- rep(list(c(-1, 1)), n)
x
sample(x = x, size = k, replace = T)
lapply(x, sample , size = k, replace = T, prob = c(0.5, .5))
a <- lapply(x, sample , size = k, replace = T, prob = c(0.5, .5))
str(a)
class(a)
dataframe(a)
b <- as.data.frame(a)
str(b)
str(a)
lapply(a, function(a){sapply(seq_along(a), function(x){sum(a[1:x])})})
b <- lapply(a, function(a){sapply(seq_along(a), function(x){sum(a[1:x])})})
b
str(b)
b <- lapply(a, function(a){c(0, sapply(seq_along(a), function(x){sum(a[1:x])}))})
str(v)
str(b)
randomWalkGenerator <- function(steps = 3000,
prob = c(0.5, 0.5),
n = 1){
x <- rep(list(c(-1, 1)), n)
X <- lapply(x,
sample,
size = steps,
replace = T,
prob = prob)
(Mk <- lapply(X, function(i){
c(0,
sapply(seq_along(i),
function(x){
sum(i[1:x])
}))
})
)
(as.data.frame(Mk))
}
randomWalkGenerator()
randomWalkGenerator(n = 2)
a <- randomWalkGenerator(n = 2)
str(a)
str(randomWalkGenerator())
library(RandomWalk)
library(RandomWalk)
rv <- randomWalk()
str(rv)
