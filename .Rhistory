install.packages("ggplot2")
library(ggplot)
library(ggplot2)
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100))
plot(Mt[range, lastToss],
fi[range, lastToss],
type = 'l',
xlim = c(-75, 75))
# Probability measure:
p <- 1/2
q <- 1 - p
size <- 300
spread <- 3000
M <- 0
###
# Mt and fi are dataframe with size = (size + 1) * (size + 1)
# All value inside Mt and fi are zero.
# check ate Initialisation section for size value.
###
Mt <- fi <- data.frame(matrix(rep(0, (size + 1)^2), nrow = size + 1))
l <- 300
k <- 200
##
# Generation
##
X <- sample(x = c(-1, 1),
size = size,
replace = T,
prob = c(p, q)
)
# Following lines must be changed into apply type function:
for(i in 1:size)
M[i + 1] <- sum(X[1:i]) # i + 1 because M[0] from theory is indeed represented by M[1] in this code.
# Same result with apply type function:
M_k <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
##
# Check by plot
##
png(filename = 'SymmetricRandomWalk.png')
plot(M_k,
type = 'l')
dev.off()
################################################################################
# Creation of a 300 steps random walk
################################################################################
##
# Construction of the theoretical Random Variable M based on the filtration F(t)
# See document "randomWalkDistributionAnalysis.jgp"
##
# Usual wrong way:
# Profiling give 1200 Ms
for(j in 1:(size + 1))
for(i in 1:j)
Mt[i,j] <- (j-i) + (1-i)
# Functional Way:
# No information from profiler: too fast
dim_x <- dim_y <- 1:(size + 1)
o <- outer(dim_x,
dim_y,
FUN=function(r,c){(r-c) + (1-c)} )
to <- t(o)
subset <- upper.tri(to, diag = T)
Mk <- to * subset
##
# Construction of the distribution of the theoretical random variable
##
# Usual wrong way:
# Profiling give 1200 Ms
for(j in 1:(size+1))
for(i in 1:j)
fi[i, j] <- choose((j-1),
(j-i)) * p^(j-1)
# Same results following funcional way
o <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
##
# Graph of the Theoretical distribution
##
png(filename = 'SymmRandWalkTheoretiaclDistrib.png')
range <- 1:ncol(Mk)
lastToss <- ncol(Mk)
# Using plot
plot(Mt[range, lastToss],
fi[range, lastToss],
type = 'l',
xlim = c(-75, 75))
# Using ggplot
# data.frame which map distribution and random variable:
distributionSymRanWal <- data.frame(
Value = Mt[range, lastToss],
Frequency = fi[range, lastToss]
)
dev.off()
library(ggplot2)
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100))
version
# Probability measure:
p <- 1/2
q <- 1 - p
size <- 300
spread <- 3000
M <- 0
###
# Mt and fi are dataframe with size = (size + 1) * (size + 1)
# All value inside Mt and fi are zero.
# check ate Initialisation section for size value.
###
Mt <- fi <- data.frame(matrix(rep(0, (size + 1)^2), nrow = size + 1))
l <- 300
k <- 200
##
# Generation
##
X <- sample(x = c(-1, 1),
size = size,
replace = T,
prob = c(p, q)
)
# Following lines must be changed into apply type function:
for(i in 1:size)
M[i + 1] <- sum(X[1:i]) # i + 1 because M[0] from theory is indeed represented by M[1] in this code.
# Same result with apply type function:
M_k <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
##
# Check by plot
##
png(filename = 'SymmetricRandomWalk.png')
plot(M_k,
type = 'l')
dev.off()
################################################################################
# Creation of a 300 steps random walk
################################################################################
##
# Construction of the theoretical Random Variable M based on the filtration F(t)
# See document "randomWalkDistributionAnalysis.jgp"
##
# Usual wrong way:
# Profiling give 1200 Ms
for(j in 1:(size + 1))
for(i in 1:j)
Mt[i,j] <- (j-i) + (1-i)
# Functional Way:
# No information from profiler: too fast
dim_x <- dim_y <- 1:(size + 1)
o <- outer(dim_x,
dim_y,
FUN=function(r,c){(r-c) + (1-c)} )
to <- t(o)
subset <- upper.tri(to, diag = T)
Mk <- to * subset
##
# Construction of the distribution of the theoretical random variable
##
# Usual wrong way:
# Profiling give 1200 Ms
for(j in 1:(size+1))
for(i in 1:j)
fi[i, j] <- choose((j-1),
(j-i)) * p^(j-1)
# Same results following funcional way
o <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
##
# Graph of the Theoretical distribution
##
png(filename = 'SymmRandWalkTheoretiaclDistrib.png')
range <- 1:ncol(Mk)
lastToss <- ncol(Mk)
# Using plot
plot(Mt[range, lastToss],
fi[range, lastToss],
type = 'l',
xlim = c(-75, 75))
# Using ggplot
# data.frame which map distribution and random variable:
distributionSymRanWal <- data.frame(
Value = Mt[range, lastToss],
Frequency = fi[range, lastToss]
)
# For the sake of visibility the limit of X axis has been set to [-100, 100]
dev.off()
dev.off()
library(ggplot2)
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100))
install.packages("knitr")
df_Mk <- as.data.frame(
cbind(
seq_along(M_k) - 1,
M_k
))
df_Mk <- as.data.frame(
cbind(
seq_along(M_k) - 1,
M_k
))
colnames(df_Mk) <- c('x', 'y')
df_Mk <- as.data.frame(
cbind(
seq_along(M_k) - 1,
M_k
))
colnames(df_Mk) <- c('x', 'y')
# Plot
ggplot(data = df_Mk, aes(x, y)) +
geom_line() +
xlab("Time") + ylab("SRW") +
theme_minimal() +
theme(text = element_text(family="CM Roman"),
axis.title = element_text(face = "plain"))
ggplot(data = df_Mk, aes(x, y)) +
geom_line() +
xlab("Time") + ylab("SRW") +
# theme_minimal() +
theme(text = element_text(family="CM Roman"),
axis.title = element_text(face = "plain"))
library(extrafont)
install.packages("extrafont")
library(extrafont)
fonts()
loadfonts()
fonts()
font_install('fontcm')
y
install.packages("fontcm")
fonts()
loadfonts()
fonts()
font_install('fontcm')
fonts()
font_install('fontcm')
library(ggplot2)
library(xtable)
library(plyr)
library(dplyr)
install.packages(c("xtable", "dplyr"))
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100)) +
theme_minimal() +
theme(text = element_text(family="CM Roman"),
axis.title = element_text(face = "plain"))
EM200 = sum(Mt[1:200, 200] * fi[1:200, 200]) # equal zero.
EM200
dim_x <- dim_y <- 1:(k + 1) # from 1 to k+1 because we start to time zero nonrandom which equal to zero
dim_x <- dim_y <- 1:(k + 1) # from 1 to k+1 because we start to time zero nonrandom which equal to zero
dim_x <- dim_y <- 1:(size + 1)
dim_x <- dim_y <- 1:(size + 1)
o <- outer(dim_x,
dim_y,
FUN=function(r,c){(r-c) + (c-1)} )
v <- 1:10
o[v,v]
o <- outer(dim_x,
dim_y,
FUN=function(r,c){(c-r) + (c-1)} )
o[v,v]
o <- outer(dim_x,
dim_y,
FUN=function(r,c){(c-r) - (c-1)} )
o[v,v]
o <- outer(dim_x,
dim_y,
FUN=function(r,c){(c-r) - (r-1)} )
o[v,v]
o <- outer(dim_x,
dim_y,
FUN=function(r,c){if(c>=r){(c-r) - (r-1)}else NA} )
o[v,v]
o <- outer(dim_x,
dim_y,
FUN=function(r,c){ifelse(c>=r, (c-r) - (r-1), NA)})
o
o[v,v]
o <- outer(dim_x,
dim_y,
FUN=function(r,c){ifelse(c>=r, (c-r) - (r-1), NA_integer_)})
o[v,v]
o <- outer(dim_x,
dim_y,
FUN=function(r,c){ifelse(c>=r, (c-r) - (r-1), NULL)})
o[v,v]
o <- outer(dim_x,
dim_y,
FUN=function(r,c){ifelse(c>=r, (c-r) - (r-1), )})
Mk_print
Mk_print <- apply(Mk, 2, function(x){as.character(x)})
Mk_print[v,v]
Mk.tab <- xtable(Mk[1:10, 1:10], digits = 0, format = "latex")
align(Mk.tab) <- rep("r", 11)
Mk.tab
Mk.tab <- xtable(Mk[1:10, 1:10], digits = 0, format = "latex")
library(xtable)
library(plyr)
library(dplyr)
Mk.tab <- xtable(Mk[1:10, 1:10], digits = 0, format = "latex")
align(Mk.tab) <- rep("r", 11)
Mk.tab
Mk[1:10, 1:10]
Mk <- outer(dim_x,
dim_y,
FUN=function(r,c){ifelse(c>=r, (c-r) - (r-1), NA_integer_)})
colnames(Mk) <- paste0("F(", 1:ncol(Mk) - 1, ")")
Mk
Mk[1:10, 1:10]
Mk.tab <- xtable(Mk[1:10, 1:10], digits = 0, format = "latex")
align(Mk.tab) <- rep("r", 11)
Mk.tab
Mk.tab <- xtable(Mk[1:10, 1:10], digits = 0, format = "latex")
Mk.tab
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100)) +
theme_minimal() +
theme(text = element_text(family="CM Roman"),
axis.title = element_text(face = "plain"))
EM200 = sum(Mk[1:200, 200] * fi[1:200, 200]) # equal zero.
EM200
Mk[1:200, 200]
fi[1:200, 200]
EM200 = sum(Mk[1:200, 200] * fi[1:200, 200]) # equal zero.
EM200
from <- 2 # Departure of the Expectation
k <- 4 # To get the filtration point
l <- 19 # Give the period to be expected
interval <- l-k
df <- data.frame(matrix(
rep(0, (interval+1)^2),
nrow = (interval+1)
))
from <- 2 # Departure of the Expectation
k <- 4 # To get the filtration point
l <- 19 # Give the period to be expected
interval <- l-k
df <- data.frame(matrix(
rep(0, (interval+1)^2),
nrow = (interval+1)
))
df
caca <- Mt[from:(from + interval), k:l]
caca
for(j in 1:(size + 1))
for(i in 1:j)
Mt[i,j] <- (j-i) + (1-i)
plot(Mt[range, lastToss],
fi[range, lastToss],
type = 'l',
xlim = c(-75, 75))
caca <- Mt[from:(from + interval), k:l]
caca
mt[2:17, 4:19]
Mt[2:17, 4:19]
Mt[v,v]
Ml[v,v]
Mk[v,v]
caca
names(df)
df <- Mt[from:(from + interval), k:l]
names(df)
df <- Mt[from:(from + interval), k:l]
names(df) <- sapply(1:interval, function(x){paste0("X",x)})
names(df)
1:interval
Mt[from:(from + interval), k:l]
length(df)
ncol(df)
df <- Mt[from:(from + interval), k:l]
names(df) <- sapply(1:ncol(df), function(x){paste0("X",x)})
names(df)
df
from <- 2 # Departure of the Expectation
k <- 4 # To get the filtration point
l <- 19 # Give the period to be expected
interval <- l-k
df <- Mk[from:(from + interval), k:l]
names(df) <- sapply(1:ncol(df), function(x){paste0("X",x)})
df
df
Mk[from:(from + interval), k:l]
df
df
df <- Mk[from:(from + interval), k:l]
df
(from + interval)
interval
from:(from + interval)
k:l
from <- 2 # Departure of the Expectation
from <- 2 # Departure of the Expectation
len <- l - k + 1
range(from:from+len)
from
range(2:4)
2:4
range(2,4)
range(from,from + len)
range(from,from + len -1)
from <- 2 # Departure of the Expectation
df
df <- Mk[from:(from + len), k:l]
df
from
Mk[v,v]
Mt[v,v]
df <- Mk[from:(from + len), k:l]
df
range(from,from + l-k)
r <- range(from,from + l-k)
seq(r, by = 1)
seq(from, from + l - k, by = 1)
from:(from + len)
len <- l - k
df <- Mk[from:(from + len), k:l]
df
fi <- data.frame(matrix(rep(0, (l-k + 1)^2), nrow = l-k + 1))
for(j in 1:(l-k+1))
for(i in 1:j)
fi[i, j] <- choose((j-1), (i-1)) * p^(j-1)#((j-1)*p^(j-1))/(factorial(j-1)*factorial(1+i))
fi
fi
df
fi <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
fi
df <- Mk[ran]
ran <- c(from:(from + len), k:l)
df <- Mk[ran]
fi_min <- fi[ran]
df
ran
ran <- cbind(from:(from + len), k:l)
df <- Mk[ran]
df
ran
ran <- rbind(from:(from + len), k:l)
ran
df <- Mk[ran]
df
i <- from:(from + len)
j <- k:l
outer(i,j,cbind)
outer(i,j,paste)
i <- from:(from + len)
j <- k:l
df <- Mk[i, j]
df
fi_min <- fi[i, j]
fi_min
df
fi_min
sum(df[, l-k+1] * fi_min[, l-k+1]) #Yeah it is a fucking matringale
l-k+1
l-k+1
df[, l-k+1]
fi_min[, l-k+1]
Mk[from, k]
sum(df[, l-k+1] * fi_min[, l-k+1]) #Yeah it is a fucking matringale
Mk[from, k + 1]
Mk[from, k]
df
sum(fi_min[, l-k+1])
sum(fi_min[, l-k])
l-k
sum(fi_min[, l-k+1])
sum(fi_min[, l-k+1] * df[, l-k+1])
fi_min[1, l-k+1]
fi[, 19]
fi <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
plot(Mk[range, lastToss],
fi[range, lastToss],
type = 'l',
xlim = c(-75, 75))
fi_min <- fi[i, j]
Mk[from, k]
sum(df[, l-k+1] * fi_min[, l-k+1]) #Yeah it is a fucking matringale
fi_min <- fi[1:(len+1), 1:(len+1)]
Mk[from, k]
sum(df[, l-k+1] * fi_min[, l-k+1]) #Yeah it is a fucking matringale
sum(df[, l-k+1] * fi_min[, l-k+1]) #Yeah it is a matringale
size <- 3000
spread <- 300000
Xs <- list()
for(i in 1:spread)
Xs[[i]] <- sample(x = c(-1, 1),
replace = T,
prob = c(p, q),
size = size)
Wn <- vector()
for(i in 1:spread)
Wn[i] <- sum(Xs[[i]])
hist(Wn)
k <- size <- 3000
n <- spread <- 300000
sample(x = c(-1, 1),
replace = T,
prob = c(p, q),
size = size)
Xs <- list()
lapply(Xs, sample, x = c(-1,1), replace = T, prob = c(p, q), size = k)
