Mt <- outer(dim_x,
dim_y,
FUN=function(r,c){ifelse(c>=r, (c-r) - (r-1), NA_integer_)})
fi <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
# CHECK: A rapid check to see if the variable [fi] contains probability by col.
#   We just have to sum up the data col by col and ensure that it provides the value 1.
#
#
Mt[,k]
Mt[,k+1]
Mt[,k+1]
k
fi[,k+1]
Mt[,k+1] * fi[,k+1]
sum(Mt[,k+1] * fi[,k+1])
sum(Mt[,k+1]^2 * fi[,k+1])
Mt[dix, dix]
sum(Mt[1:10, 1:10]^2 * fi[1:10, 1:10])
Mt[1:10, 1:10]
fi[1:10, 1:10]
Mt[1:10, 1:10]^2
Mt[1:10, 10]
sum(Mt[1:10, 10]^2 * fi[1:10, 10])
W <- seq(from = 0,
to = 1,
by = .0001)
W
W[1]
W[length(W)]
tail(W)
mean(W)
punif(W)[length(W) / 2]
punif(W)[length(W) / 2]
length(W)
punif(W)
punif(W)[length(W) / 2]
?punif
punif(0.4)
punif(0.7)
punif(1)
plot(punif(W))
p <- 1/2
q <- 1 - p
# number of exeriments: expe
expe <- 100000
n <- 100
YPrime <- Y
for(i in 1:expe)
for(j in 1:n)
YPrime[[i]][j] <- Y[[i]][j] / 2^j
Y = list()
for(i in 1:expe){
Y[[i]] <- rbinom(n = n,
size = 1,
prob = p)
}
Y
YPrime <- Y
for(i in 1:expe)
for(j in 1:n)
YPrime[[i]][j] <- Y[[i]][j] / 2^j
YPrime
X <- vector()
for(i in 1:expe)
X[i] <- sum(YPrime[[i]])
X
ProbX <- 1 / 2 ^ n
ProbX
?seq
sample()
?sample
sample(c(1,0))
bobo <- function(r, c){
paste(r, c, ',')
}
Y <- outer(1:n, 1:2^n, bobo)
Y <- outer(1:n, 1:(2^n), bobo)
n <- 3
Y <- outer(1:n, 1:(2^n), bobo)
Y
Y <- outer(1:(2^n), 1:n, bobo)
Y
bobo <- function(r, c){
paste(r, c, sep = ',')
}
Y <- outer(1:(2^n), 1:n, bobo)
Y
n <- 3
bobo <- function(r, c, n){
paste(r, c,n,  sep = ',')
}
Y <- outer(1:(2^n), 1:n, bobo)
bobo <- function(r, c){
paste(r, c,n,  sep = ',')
}
Y <- outer(1:(2^n), 1:n, bobo)
Y
seq(1)
?seq
seq(1, length.out = 4)
rep(1, 4)
Y <- data.frame(rep(1, n * (2^n)), nrow = (2^n))
Y
Y <- matrix(rep(1, n * (2^n)), nrow = (2^n))
Y
lapply(Y, function(x){x})
apply(Y, function(x){x * 2})
apply(Y, FUN = function(x){x * 2})
apply(Y, 2, FUN = function(x){x * 2})
bobo <- function(c){
paste(c,n,  sep = ',')
}
apply(Y, 2, FUN = bobo(c))
bobo <- function(c){
c
}
apply(Y, 2, FUN = bobo(c))
bobo <- function(c){
c[0]
}
apply(Y, 2, FUN = bobo(c))
bobo <- function(c){
i++
}
bobo <- function(c){
i <- i + 1
}
apply(Y, 2, FUN = bobo(c), i = 0)
bobo <- function(c){
i <- i + 1
i
}
apply(Y, 2, FUN = bobo(c), i = 0)
bobo <- function(c, i){
i <- i + 1
i
}
apply(Y, 2, FUN = bobo(c), i = 0)
apply(Y, 2, FUN = bobo(c, i), i = 0)
apply(Y, 2, FUN = bobo(c),  0)
expand.grid(c(0,1))
expand.grid(c(0,1). c(0,1))
expand.grid(c(0,1), c(0,1))
expand.grid(c(0,1), c(0,1), c(0,1))
expand.grid(rep(c(0,1), n))
rep(c(0,1), n)
matrix(c(1,0, 1, 0), ncol = 2)
matrix(c(1,0, 1, 0), nrow = 2)
a <- matrix(c(1,0, 1, 0), nrow = 2)
a
expand.grid(a)
expand.grid(rep(list(1,0), 3))
rep(list(1, 0), 3)
expand.grid(rep(list(c(1,0)), 3))
expand.grid(rep(list(c(0, 1)), 3))
expand.grid(rep(list(c(1, 0)), 3))
Y <- expand.grid(rep(list(c(1,0)), 3))
Y
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- n
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- 100
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- 50
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- 20
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- 30
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- 40
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- 23
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
X <- rowSums(Y)
X
n <- 3
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- 4
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y
Y/2
apply(Y, 2)
apply(Y, 2, Y/2)
apply(Y, 2, function(x) x/2)
apply(Y, 2, function(x) x/1:4)
apply(Y, 1, function(x) x/1:4)
t(apply(Y, 1, function(x) x/1:4))
t(apply(Y, 1, function(x) x/(1:4)))
t(apply(Y, 1, function(x) x/2^(1:4)))
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^1:n))
Y
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^(1:n)))
Y
n
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^(1:n)))
Y
X <- rowSums(Y)
X
n <- 25
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^(1:n)))
rm(list = ls())
gc(verbose = T)
n <- 25
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^(1:n)))
n <- 20
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^(1:n)))
X <- rowSums(Y)
X[1]
X[2]
X[3]
X[4]
X[5]
X[length(X)]
X <- order(X)
head(X)
?order
X <- rowSums(Y)
X <- sort(X)
X
head(X)
tail(X)
X <- sort(rowSums(Y), decreasing = T)
plot(X)
#################################################################
# Example 1.2.5: Another random variable uniformly distributed.
################################################################
# W random variables included various value from 0 to one.
# All UNIFORMALY distributed.
W <- seq(from = 0,
to = 1,
by = .0001)
#
# Define the probability measure p & q
p <- 1/2
q <- 1 - p
# number of exeriments: expe
expe <- 100000
# Sample size:
n <- 100
##
# Construction of the theoretical distribution of X
#
# Not consider the infinite sample space but instead a rather large one
#
#   * [n]: It gives the number of columns.
#   * [2^n]: Gives the number of rows.
##
n <- 20
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^(1:n)))
X <- sort(rowSums(Y), decreasing = T)
length(X)
distrib_X <- data.frame('X' = X, 'P' = 1/length(X))
head(distrib_X)
sum(rowSums(distrib_X))
sum(distrib_X[1] * distrib_X[2])
sum(distrib_X[2])
sum(rowProds(distrib_X))
install.packages("matrixStats")
library(matrixStats)
sum(rowProds(distrib_X))
sum(rowProds(as.matrix(distrib_X)))
probX <- 1/length(X)
sum(X * probX)
distrib_X <- data.frame('X' = X,
'P' = 1/length(X),
'F' = seq(0, 1, by = 1/length(X)))
distrib_X <- data.frame('X' = X,
'P' = 1/length(X),
'F' = seq(1/length(X), 1, by = 1/length(X)))
head(distrib_X)
tail(distrib_X)
library(ggplot2)
ggplot(distrib_X, aes(X, F)) +
geom_line()
a <- 0.125
X <- rowSums(Y)
distrib_X <- data.frame('X' = X,
'P' = 1/length(X),
'F' = seq(2/length(X), 1, by = 1/length(X)))
X <- rowSums(Y)
distrib_X <- data.frame('X' = X,
'P' = 1/length(X),
'F' = seq(2/length(X), 1, by = 1/length(X)))
distrib_X <- data.frame('X' = X,
'P' = 1/length(X),
'F' = seq(1/length(X), 1, by = 1/length(X)))
ggplot(distrib_X, aes(X, F)) +
geom_line()
ggplot(distrib_X, aes(X, F)) +
geom_point()
#################################################################
# Example 1.2.5: Another random variable uniformly distributed.
################################################################
library(ggplot2)
# W random variables included various value from 0 to one.
# All UNIFORMALY distributed.
W <- seq(from = 0,
to = 1,
by = .0001)
#
# Define the probability measure p & q
p <- 1/2
q <- 1 - p
# number of exeriments: expe
expe <- 100000
# Sample size:
n <- 100
##
# Construction of the theoretical distribution of X
#
# Not consider the infinite sample space but instead a rather large one
#
#   * [n]: It gives the number of columns.
#   * [2^n]: Gives the number of rows.
##
n <- 20
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^(1:n)))
X <- rowSums(Y)
ordered_X <- sort(rowSums(Y), decreasing = T)
distrib_X <- data.frame('X' = X,
'P' = 1/length(X),
'F' = seq(1/length(X), 1, by = 1/length(X)))
ggplot(distrib_X, aes(X, F)) +
geom_point()
# Find the expected value:
prob_X <- 1/length(X)
sum(X * prob_X)
##
# Next: Convergence of Integrals.
##
#
# Y should be constructed according to some random experiment.
Y = list()
for(i in 1:expe){
Y[[i]] <- rbinom(n = n,
size = 1,
prob = p)
}
# According to Y, construction of X:
# X should be a random variable construct upon a vector
# Transformation of Y
YPrime <- Y
for(i in 1:expe)
for(j in 1:n)
YPrime[[i]][j] <- Y[[i]][j] / 2^j
X <- vector()
for(i in 1:expe)
X[i] <- sum(YPrime[[i]])
# Probability that the value of X fall between 4/3000 and 5/3000:
ProbX <- 1 / 2 ^ n
####################################################
#  Check of the theory
####################################################
# Probability that X is in the interval:
# [0, 3e29/2^n]:
probI <- (3e29 - 0)/2^n
# Check:
length(X[X < 3e29/2^n]) / length(X)
# Probability that X is in the interval:
# [3e28/2^n, 3e29/2^n]:
probI <- (3e29 - 3e28)/2^n
# Check:
length(X[X > 3e28/2^n & X < 3e29/2^n]) / length(X)
#################################################################
# Example 1.2.5: Another random variable uniformly distributed.
################################################################
library(ggplot2)
# W random variables included various value from 0 to one.
# All UNIFORMALY distributed.
W <- seq(from = 0,
to = 1,
by = .0001)
#
# Define the probability measure p & q
p <- 1/2
q <- 1 - p
# number of exeriments: expe
expe <- 100000
# Sample size:
n <- 100
##
# Construction of the theoretical distribution of X
#
# Not consider the infinite sample space but instead a rather large one
#
#   * [n]: It gives the number of columns.
#   * [2^n]: Gives the number of rows.
##
n <- 20
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^(1:n)))
X <- sort(rowSums(Y), decreasing = T)
distrib_X <- data.frame('X' = X,
'P' = 1/length(X),
'F' = seq(1/length(X), 1, by = 1/length(X)))
ggplot(distrib_X, aes(X, F)) +
geom_point()
# Find the expected value:
prob_X <- 1/length(X)
sum(X * prob_X)
##
# Next: Convergence of Integrals.
##
#
# Y should be constructed according to some random experiment.
Y = list()
for(i in 1:expe){
Y[[i]] <- rbinom(n = n,
size = 1,
prob = p)
}
# According to Y, construction of X:
# X should be a random variable construct upon a vector
# Transformation of Y
YPrime <- Y
for(i in 1:expe)
for(j in 1:n)
YPrime[[i]][j] <- Y[[i]][j] / 2^j
X <- vector()
for(i in 1:expe)
X[i] <- sum(YPrime[[i]])
# Probability that the value of X fall between 4/3000 and 5/3000:
ProbX <- 1 / 2 ^ n
####################################################
#  Check of the theory
####################################################
# Probability that X is in the interval:
# [0, 3e29/2^n]:
probI <- (3e29 - 0)/2^n
# Check:
length(X[X < 3e29/2^n]) / length(X)
# Probability that X is in the interval:
# [3e28/2^n, 3e29/2^n]:
probI <- (3e29 - 3e28)/2^n
# Check:
length(X[X > 3e28/2^n & X < 3e29/2^n]) / length(X)
