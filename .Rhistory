############################
#
# Exhibits some arbitrage opportunity.
#
# First one (1.1.2) does not hold for the inequality: d < 1+r
# In other words, we get the following inequalities, which led to
# an arbitrage opportunity:
#
#     0 < 1+r < d < u
#
# With the previous configuration, one can:
#   1.  Borrow some money in the money market at rate [r]
#   2.  Buy shares of stock that provides in the worst case a return of:
#       [d*S0].
#   3.  The return provided by the share at time 1 is much that the money owe to
#       the money market
#
#
# Next, consider the inequality: 0 < d < u < 1+r.
#
# Particularly this inequality means that it would be more profitable
# to invest in money market than in stock. A paradoxical issue arise because
# investing in mony market security brings less risk than investing in shares
# and therefore money market investment shoud be less valueable.
#
# However if the previous inequality arise (u < 1+r), one achieve an arbitrage
# opportunity with the following strategy:
#   1.  Sell short the stock.
#   2.  Investing the money provided by the short selling of the stock
#       in a money market account.
#   3.  At maturity (t=1) receive the paiment of the principal + the interest
#       and use it to pay off the short selling.
# As in the best case the stock has rose less than the money market account.
# One finish with a profit without the risk of lost.
#
#
# A definition of arbitrage is provided on page 2:
#   Arbitrage:  Trading strategy that begins with no money, has zero probability
#               of losing money, and has a positive probability of making money.
############################
# Replication take place   #
############################
#
# Some definitions:
#
#   * European call option: Options which confers on its owners the right
#       but not the obligation to buy one share of stock at time one for
#       a predetermined price called the strike price.
#
#   * European put option: Options which confers on its owners the right
#       but not the obligation to sell one share of stockt at time one for
#       a predertermined price called the stroke.
#
#   * European vs. American: The only difference between these kind of options
#       is that the European option can only be exercised at maturity whereas
#       an American one could be exercised at any time before maturity.
#
# The position in option also are important to be mentioned:
#
#   * Long position: Buyer of the option. In this position one purchase the
#       right but not the obligation to exercise it.
#
#   * Short position: Seller of the option. In this position one must sell or
#       buy the underlying according to the fact that the long position
#       choose to exercises its right or not.
#
# arbitrage trading theory is an approach of the option-pricing problem that
# consists on replicate the option by trading in the stock and money market.
#
# An example using the values defined just above.
# Reminder of the value associated to the different variables:
#     * period  <- c(0,1)
#     * S0      <- 4
#     * k       <- 5
#     * u       <- 2
#     * r       <- 1/4
#     * p       <- 0.5
#     * X0      <- 1.20
#     * delta0  <- 0.5
#
# Gain in the case the stock price goes to head at T1
#
# Variables
#   * [InitialPortFolioValue]: The value of the portfolio at T0 (Not random)
#   * [LongPosition]: The long position in the option.
#                     (Mean the holder of the right over the underlying)
#     * ['H']: If the coin toss result to head
#     * ['T']: If the coin toss result to tail
#   * [ShortPosition]: The short position in the option.
#                       (Concerne the one which hold a claim)
#     * ['H']: If the coin toss result to head
#     * ['T']: If the coin toss result to tail
#   * [MoneyMarketValue]: The growth of the value invested / borrowed
#                         to the money market
#     * [+]: The value is positive if one invests in MM
#     * [-]: The value is negative if one borrows in MM
#   * [StockHoldingMarketValue]: Value of the stock according to the delta
#                                 (The amount hold by the hedger)
#     * ['H']: If the coin toss result to head
#     * ['T']: If the coin toss result to tail
#   * [PortfolioValue]: The value of the portfolio at T1 except the value of the
#                       stock option hold or owe.
#     * ['H']: If the coin toss result to head
#     * ['T']: If the coin toss result to tail
#
LongPosition  <- c('H' = max(S1H - k, 0),
'T'= max(S1T - k, 0))
ShortPosition <- c('H' = min(k - S1H, 0),
'T' = min(k - S1T, 0))
#
# If a head occurs:
#   -> The short position value is -3. Thus to replicate the position we must do
#       a trade that provide 3 at T1
# If a tail occurs:
#   -> The short position value is 0. Thus to replicate the position we must do
#       a trade that provide 0 at T1
#
############################
# hedge of short position  #
############################
# At time zero the value of the portfolio is:
#  (This is the only value which is not random)
#
InitialPortfolioValue <- X0 - delta0 * stockPricePath[1,1]
# At Time one if the coin toss results to head/tail we get
# (as holder of short position):
MoneyMarketValue <- InitialPortfolioValue * (1 + r)
StockHoldingMarketValue <- c('H' = delta0 * S1H,
'T' = delta0 * S1T)
# For the following code the name 'H' and 'T' has not been set up
# especially to not duplicate the information inside the vector [PortfolioValue]
#
PortfolioValue <- c(MoneyMarketValue + StockHoldingMarketValue['H'],
MoneyMarketValue + StockHoldingMarketValue['T'])
#
# If following check is TRUE then the short position has been replicated:
#
if ( identical(PortfolioValue, -1 * ShortPosition) )
print(paste('Ok the short position has been replicated and the value',
'of the option at T0 should be fixed at',
paste0('$',X0),
'to avoid arbitrage', sep = ' ')) else
print('Fuck off, the computation lead to a universe black hole...')
#
# The previous check verify the hedge and return:
#
# [1] "Ok the short position has been replicated and the value of the option
#     at T0 should be fixed at $1.2 to avoid arbitrage"
#
############################
# hedge of long position   #
############################
#
# To hedge the long position one have only to do the reverse of the previous
# strategy
#
############################
# Hedging strategy's eq.   #
############################
#
# Here the equations to place a hedge for short and long position are developped
# First the variable used to model the hegde has to be defined.
#
# Some are unknowns
#   * [X0]: Initial wealth
#   * [delta0]:
#
# Other though possibly random are knowns and are used as independent variables
# to model the hedge:
#   * [S0]: stockPricePath[1,1]
#   * [S1]:
#   * [V0]:
#   * [V1]:
#   * [u]:
#   * [d]:
#   * [r]:
#   * [k]:
#   * [deltaNeutralProbability]:
#
# The basis of the model is that X0 must equal V0 to conclude that the hedge
# works.
##
# First: Hedge of the short position in the option.
#
# One first starts with initial wealth [X0] and would buy a certain amount
# of share of stock [delta0]. This operation let him with a cash position of:
#
#   [cashPosition[T0]]: X0 - delta0 * stockPricePath[1,1]
#
#   *[X0]: is unknown
#   *[delta0]: is unknown
#   *[S0]: is known
#
# The prevours initial cash position would be invested (if positive) or borrowed
# (if negative) from the money market. This would let him with a [portfolioValue]
# at T1:
#
#   [portfolioValue[T1]] = (delta0 * S1) + (1+r)(X0 - delta0 * S0)
#
# The previous formula could be rewrite as:
#
#   [portfolioValue[T1]] = (1+r) * X0 + delta0 * (S1 - (1+r) * S0)
#
pvh <- (1+r) * X0 + delta0 * (S1H - (1+r) * unname(stockPricePath[1,1]))
pvt <- (1+r) * X0 + delta0 * (S1T - (1+r) * unname(stockPricePath[1,1]))
portfolioValue <- matrix(data = c(pvh, pvt),
dimnames = list(c(t1),
c('H', 'T')))
library(ggplot2)
p <- 1/2
q <- 1 - p
######################################################################
#
# Chapter 3 > 3.2 Scaled symmetric random walk
#
# TODO: section: Create an array of (3000) steps sample random walk
# Work to find a solution for functionnal way of doing the stuff
#
######################################################################
#
# Library
#
library(ggplot2)
#
# Probability measure:
#
# For the purpose of this theory, first are define the probabilities p and q such as it has the same occurence (one half)
#
p <- 1/2
q <- 1 - p
#
# Some graphics will be created inside this folder:
# code\Chapter3\figure
#
# To access the content of this folder, the variable figure could be used for:
#
figure <- paste(getwd(), 'Chapter3', 'figure', sep = '/')
#
# Definition of the symmetric random walk
#
# The symmetric random walk is first defined by some samples (which makes an array of sampled symmetric random walk)
# Variables:
#   * [k]: The size of the sample is denoted by the variable k -> (see theory $M_k$ denote the Symmetric Random Walk variable)
#   * [asize]: length of the array containing the Symmetric Random Walks
#
# Next it will be defined by its distributions.
#
# Both will be use full for finding expectation and variance theoterically or empirically
#
k <- 3000
asize <- 75000
###################################
# Empirical Symmetric Random Walk #
###################################
#
# Construction on the Empirical Random variable X
X <- sample(x = c(-1, 1),
size = k,
replace = T,
prob = c(p, q)
)
#
# Construction of the Empirical Random Walk
#
Mk <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
##
# Check by plot
##
file <- paste(figure, 'EmpiricalSymmetricRandomWalkSample.pdf', sep = '/')
pdf(file = file)
plot(Mk,
type = 'l')
dev.off()
######################################################
# Create an array of (3000) steps sample random walk #
######################################################
#
#   *[Mkr] Array of [asize] number of Symmetric Random Walk
#
Mkr <- matrix(data = sample(x = c(-1, 1),
replace = T,
prob = c(p, q),
size = k*asize),
nrow = asize,
ncol = k
)
#
# Calculate the empirical distribution
# First by computing the Expectation
#
#   *[Mki] : Array containing the final step of the random work at time F(T)
#   *[Empir] :  Empirical expectation of Symmetric Random Walk.
X <- sample(x = c(-1, 1),
size = k,
replace = T,
prob = c(p, q)
)
X <- sample(x = c(-1, 1),
size = k,
replace = T,
prob = c(p, q)
)
Mk <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
Mk <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
Mk <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
Mkr <- matrix(data = sample(x = c(-1, 1),
replace = T,
prob = c(p, q),
size = k*asize),
nrow = asize,
ncol = k
)
Mkr
Mkr
Mki <- rowSums(Mkr)
Empir <- mean(Mki)
Empir
Mkd <- cbind(RandomValue = Mki,
Frequency = 1/length(Mki))
MkHistogramFormated <- aggregate(Frequency ~ RandomValue, Mkd, sum)
ggplot(as.data.frame(Mkd), aes(RandomValue)) +
geom_histogram(aes(y = (..count..)/sum(..count..)),
binwidth = 10) +
scale_y_continuous(labels = scales::percent)
pdf(file = file)
ggplot(as.data.frame(Mkd), aes(RandomValue)) +
geom_histogram(aes(y = (..count..)/sum(..count..)),
binwidth = 10) +
scale_y_continuous(labels = scales::percent)
dev.off()
dim_x <- dim_y <- 1:(k + 1)
dim_x
str(dim_x)
Mt <- outer(dim_x,
dim_y,
FUN=function(r,c){ifelse(c>=r, (c-r) - (r-1), NA_integer_)})
Mt[1:10, 1:10]
fi <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
dix <- 1:10
fi[dix, dix]
a <- colSums(fi)
str(a)
sum(a)
typeof(a)
a
sum(a)
sum(1:10)
a[a != 1]
fi[, 990]
sum(fi[, 990])
fi[dix, dix]
colSums(fi)
a <- colSums(fi)
a[a != 1]
a != 1
a[1]
a[1] == 1
a[61] == 1
a[61]
typeof(a[61])
a[61]+1
range <- dim_x
lastToss <- length(dim_y)
distributionSymRanWal <- data.frame(
Value = Mt[range, lastToss],
Frequency = fi[range, lastToss]
)
file <- paste(figure, 'SymmetricRandomWalkDistribution.pdf', sep = '/')
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100))
distributionSymRanWal
fi[range, lastToss]
fi <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
range <- dim_x
lastToss <- length(dim_y)
lastToss
str(fi)
range
str(range)
fi[,lastToss]
fi[,3000]
fi[,2500]
dim_x
dim_y
fi <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
fi[,1000]
fi[,2000]
fi[,1500]
fi[,1200]
fi[,1100]
fi[,1050]
fi[,1070]
fi[,1090]
choose((2000-1), (2000-1000)) * 0.5^(2000-1)
choose((1020-1), (1020-1000)) * 0.5^(1020-1)
0.5^1999
0.5^1000
0.5^1500
dim_x <- dim_y <- 1:(k + 1)
k <- 1000
dim_x <- dim_y <- 1:(k + 1)
Mt <- outer(dim_x,
dim_y,
FUN=function(r,c){ifelse(c>=r, (c-r) - (r-1), NA_integer_)})
fi <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
if(mean(colSums(fi)) == 1) print("Ok the sum of the whole sample set OMEGA equal ONE :)")
mean(colSums(fi))
mean(colSums(fi)) == 1
mean(colSums(fi)) == 1.
1.
1 == 1
a <- mean(colSums(fi))
a
typeof(a)
class(a)
typeof(1)
class(1)
a == 1
ceil(a)
floor(a)
round(a)
round(a) == 1
if(round(mean(colSums(fi)) == 1)) print("Ok the sum of the whole sample set OMEGA equal ONE :)")
round(mean(colSums(fi)) == 1)
if(round(mean(colSums(fi))) == 1) print("Ok the sum of the whole sample set OMEGA equal ONE :)")
range <- dim_x
lastToss <- length(dim_y)
distributionSymRanWal <- data.frame(
Value = Mt[range, lastToss],
Frequency = fi[range, lastToss]
)
file <- paste(figure, 'SymmetricRandomWalkDistribution.pdf', sep = '/')
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100))
pdf(file = file)
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100))
dev.off()
X
Mk
Xk <- c(1, -1)
Ex <- weighted.mean(Xk, c(p, q))
Ex
Ex.square <- weighted.mean(Xk^2, c(p, q))
Ex.square
S <- Ex.square - Ex^2
S
EM200 = sum(Mt[1:200, 200] * fi[1:200, 200]) # equal zero.
EM200
from  <- 2
k     <- 4
l     <- 19
len     <- abs(l - k)
i       <- from:(from + len)
j       <- k:l
df      <- Mt[i, j]
fi_min  <- fi[1:(len+1), 1:(len+1)]
#
ifelse(Mt[from, k] == sum(df[, l-k+1] * fi_min[, l-k+1]),
"martingale!",
'Not a martingale')
Mt[dix, dix]
Mt
mt[,k]
Mt[,k]
Mt[,k]
k
k <- 1000
dim_x <- dim_y <- 1:(k + 1)
Mt <- outer(dim_x,
dim_y,
FUN=function(r,c){ifelse(c>=r, (c-r) - (r-1), NA_integer_)})
Mt <- outer(dim_x,
dim_y,
FUN=function(r,c){ifelse(c>=r, (c-r) - (r-1), NA_integer_)})
fi <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
# CHECK: A rapid check to see if the variable [fi] contains probability by col.
#   We just have to sum up the data col by col and ensure that it provides the value 1.
#
#
Mt[,k]
Mt[,k+1]
Mt[,k+1]
k
fi[,k+1]
Mt[,k+1] * fi[,k+1]
sum(Mt[,k+1] * fi[,k+1])
sum(Mt[,k+1]^2 * fi[,k+1])
Mt[dix, dix]
sum(Mt[1:10, 1:10]^2 * fi[1:10, 1:10])
Mt[1:10, 1:10]
fi[1:10, 1:10]
Mt[1:10, 1:10]^2
Mt[1:10, 10]
sum(Mt[1:10, 10]^2 * fi[1:10, 10])
