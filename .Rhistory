)
#
# Construction of the Empirical Random Walk
#
Mk <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
##
# Check by plot
##
file <- paste(figure, 'EmpiricalSymmetricRandomWalkSample.pdf', sep = '/')
pdf(file = file)
plot(Mk,
type = 'l')
dev.off()
######################################################
# Create an array of (3000) steps sample random walk #
######################################################
#
#   *[Mkr] Array of [asize] number of Symmetric Random Walk
#
Mkr <- matrix(data = sample(x = c(-1, 1),
replace = T,
prob = c(p, q),
size = k*asize),
nrow = asize,
ncol = k
)
#
# Calculate the empirical distribution
# First by computing the Expectation
#
#   *[Mki] : Array containing the final step of the random work at time F(T)
#   *[Empir] :  Empirical expectation of Symmetric Random Walk.
X <- sample(x = c(-1, 1),
size = k,
replace = T,
prob = c(p, q)
)
X <- sample(x = c(-1, 1),
size = k,
replace = T,
prob = c(p, q)
)
Mk <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
Mk <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
Mk <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
Mkr <- matrix(data = sample(x = c(-1, 1),
replace = T,
prob = c(p, q),
size = k*asize),
nrow = asize,
ncol = k
)
Mkr
Mkr
Mki <- rowSums(Mkr)
Empir <- mean(Mki)
Empir
Mkd <- cbind(RandomValue = Mki,
Frequency = 1/length(Mki))
MkHistogramFormated <- aggregate(Frequency ~ RandomValue, Mkd, sum)
ggplot(as.data.frame(Mkd), aes(RandomValue)) +
geom_histogram(aes(y = (..count..)/sum(..count..)),
binwidth = 10) +
scale_y_continuous(labels = scales::percent)
pdf(file = file)
ggplot(as.data.frame(Mkd), aes(RandomValue)) +
geom_histogram(aes(y = (..count..)/sum(..count..)),
binwidth = 10) +
scale_y_continuous(labels = scales::percent)
dev.off()
dim_x <- dim_y <- 1:(k + 1)
dim_x
str(dim_x)
Mt <- outer(dim_x,
dim_y,
FUN=function(r,c){ifelse(c>=r, (c-r) - (r-1), NA_integer_)})
Mt[1:10, 1:10]
fi <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
dix <- 1:10
fi[dix, dix]
a <- colSums(fi)
str(a)
sum(a)
typeof(a)
a
sum(a)
sum(1:10)
a[a != 1]
fi[, 990]
sum(fi[, 990])
fi[dix, dix]
colSums(fi)
a <- colSums(fi)
a[a != 1]
a != 1
a[1]
a[1] == 1
a[61] == 1
a[61]
typeof(a[61])
a[61]+1
range <- dim_x
lastToss <- length(dim_y)
distributionSymRanWal <- data.frame(
Value = Mt[range, lastToss],
Frequency = fi[range, lastToss]
)
file <- paste(figure, 'SymmetricRandomWalkDistribution.pdf', sep = '/')
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100))
distributionSymRanWal
fi[range, lastToss]
fi <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
range <- dim_x
lastToss <- length(dim_y)
lastToss
str(fi)
range
str(range)
fi[,lastToss]
fi[,3000]
fi[,2500]
dim_x
dim_y
fi <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
fi[,1000]
fi[,2000]
fi[,1500]
fi[,1200]
fi[,1100]
fi[,1050]
fi[,1070]
fi[,1090]
choose((2000-1), (2000-1000)) * 0.5^(2000-1)
choose((1020-1), (1020-1000)) * 0.5^(1020-1)
0.5^1999
0.5^1000
0.5^1500
dim_x <- dim_y <- 1:(k + 1)
k <- 1000
dim_x <- dim_y <- 1:(k + 1)
Mt <- outer(dim_x,
dim_y,
FUN=function(r,c){ifelse(c>=r, (c-r) - (r-1), NA_integer_)})
fi <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
if(mean(colSums(fi)) == 1) print("Ok the sum of the whole sample set OMEGA equal ONE :)")
mean(colSums(fi))
mean(colSums(fi)) == 1
mean(colSums(fi)) == 1.
1.
1 == 1
a <- mean(colSums(fi))
a
typeof(a)
class(a)
typeof(1)
class(1)
a == 1
ceil(a)
floor(a)
round(a)
round(a) == 1
if(round(mean(colSums(fi)) == 1)) print("Ok the sum of the whole sample set OMEGA equal ONE :)")
round(mean(colSums(fi)) == 1)
if(round(mean(colSums(fi))) == 1) print("Ok the sum of the whole sample set OMEGA equal ONE :)")
range <- dim_x
lastToss <- length(dim_y)
distributionSymRanWal <- data.frame(
Value = Mt[range, lastToss],
Frequency = fi[range, lastToss]
)
file <- paste(figure, 'SymmetricRandomWalkDistribution.pdf', sep = '/')
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100))
pdf(file = file)
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100))
dev.off()
X
Mk
Xk <- c(1, -1)
Ex <- weighted.mean(Xk, c(p, q))
Ex
Ex.square <- weighted.mean(Xk^2, c(p, q))
Ex.square
S <- Ex.square - Ex^2
S
EM200 = sum(Mt[1:200, 200] * fi[1:200, 200]) # equal zero.
EM200
from  <- 2
k     <- 4
l     <- 19
len     <- abs(l - k)
i       <- from:(from + len)
j       <- k:l
df      <- Mt[i, j]
fi_min  <- fi[1:(len+1), 1:(len+1)]
#
ifelse(Mt[from, k] == sum(df[, l-k+1] * fi_min[, l-k+1]),
"martingale!",
'Not a martingale')
Mt[dix, dix]
Mt
mt[,k]
Mt[,k]
Mt[,k]
k
k <- 1000
dim_x <- dim_y <- 1:(k + 1)
Mt <- outer(dim_x,
dim_y,
FUN=function(r,c){ifelse(c>=r, (c-r) - (r-1), NA_integer_)})
Mt <- outer(dim_x,
dim_y,
FUN=function(r,c){ifelse(c>=r, (c-r) - (r-1), NA_integer_)})
fi <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
# CHECK: A rapid check to see if the variable [fi] contains probability by col.
#   We just have to sum up the data col by col and ensure that it provides the value 1.
#
#
Mt[,k]
Mt[,k+1]
Mt[,k+1]
k
fi[,k+1]
Mt[,k+1] * fi[,k+1]
sum(Mt[,k+1] * fi[,k+1])
sum(Mt[,k+1]^2 * fi[,k+1])
Mt[dix, dix]
sum(Mt[1:10, 1:10]^2 * fi[1:10, 1:10])
Mt[1:10, 1:10]
fi[1:10, 1:10]
Mt[1:10, 1:10]^2
Mt[1:10, 10]
sum(Mt[1:10, 10]^2 * fi[1:10, 10])
W <- seq(from = 0,
to = 1,
by = .0001)
W
W[1]
W[length(W)]
tail(W)
mean(W)
punif(W)[length(W) / 2]
punif(W)[length(W) / 2]
length(W)
punif(W)
punif(W)[length(W) / 2]
?punif
punif(0.4)
punif(0.7)
punif(1)
plot(punif(W))
p <- 1/2
q <- 1 - p
# number of exeriments: expe
expe <- 100000
n <- 100
YPrime <- Y
for(i in 1:expe)
for(j in 1:n)
YPrime[[i]][j] <- Y[[i]][j] / 2^j
Y = list()
for(i in 1:expe){
Y[[i]] <- rbinom(n = n,
size = 1,
prob = p)
}
Y
YPrime <- Y
for(i in 1:expe)
for(j in 1:n)
YPrime[[i]][j] <- Y[[i]][j] / 2^j
YPrime
X <- vector()
for(i in 1:expe)
X[i] <- sum(YPrime[[i]])
X
ProbX <- 1 / 2 ^ n
ProbX
?seq
sample()
?sample
sample(c(1,0))
bobo <- function(r, c){
paste(r, c, ',')
}
Y <- outer(1:n, 1:2^n, bobo)
Y <- outer(1:n, 1:(2^n), bobo)
n <- 3
Y <- outer(1:n, 1:(2^n), bobo)
Y
Y <- outer(1:(2^n), 1:n, bobo)
Y
bobo <- function(r, c){
paste(r, c, sep = ',')
}
Y <- outer(1:(2^n), 1:n, bobo)
Y
n <- 3
bobo <- function(r, c, n){
paste(r, c,n,  sep = ',')
}
Y <- outer(1:(2^n), 1:n, bobo)
bobo <- function(r, c){
paste(r, c,n,  sep = ',')
}
Y <- outer(1:(2^n), 1:n, bobo)
Y
seq(1)
?seq
seq(1, length.out = 4)
rep(1, 4)
Y <- data.frame(rep(1, n * (2^n)), nrow = (2^n))
Y
Y <- matrix(rep(1, n * (2^n)), nrow = (2^n))
Y
lapply(Y, function(x){x})
apply(Y, function(x){x * 2})
apply(Y, FUN = function(x){x * 2})
apply(Y, 2, FUN = function(x){x * 2})
bobo <- function(c){
paste(c,n,  sep = ',')
}
apply(Y, 2, FUN = bobo(c))
bobo <- function(c){
c
}
apply(Y, 2, FUN = bobo(c))
bobo <- function(c){
c[0]
}
apply(Y, 2, FUN = bobo(c))
bobo <- function(c){
i++
}
bobo <- function(c){
i <- i + 1
}
apply(Y, 2, FUN = bobo(c), i = 0)
bobo <- function(c){
i <- i + 1
i
}
apply(Y, 2, FUN = bobo(c), i = 0)
bobo <- function(c, i){
i <- i + 1
i
}
apply(Y, 2, FUN = bobo(c), i = 0)
apply(Y, 2, FUN = bobo(c, i), i = 0)
apply(Y, 2, FUN = bobo(c),  0)
expand.grid(c(0,1))
expand.grid(c(0,1). c(0,1))
expand.grid(c(0,1), c(0,1))
expand.grid(c(0,1), c(0,1), c(0,1))
expand.grid(rep(c(0,1), n))
rep(c(0,1), n)
matrix(c(1,0, 1, 0), ncol = 2)
matrix(c(1,0, 1, 0), nrow = 2)
a <- matrix(c(1,0, 1, 0), nrow = 2)
a
expand.grid(a)
expand.grid(rep(list(1,0), 3))
rep(list(1, 0), 3)
expand.grid(rep(list(c(1,0)), 3))
expand.grid(rep(list(c(0, 1)), 3))
expand.grid(rep(list(c(1, 0)), 3))
Y <- expand.grid(rep(list(c(1,0)), 3))
Y
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- n
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- 100
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- 50
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- 20
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- 30
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- 40
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- 23
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
X <- rowSums(Y)
X
n <- 3
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
n <- 4
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y
Y/2
apply(Y, 2)
apply(Y, 2, Y/2)
apply(Y, 2, function(x) x/2)
apply(Y, 2, function(x) x/1:4)
apply(Y, 1, function(x) x/1:4)
t(apply(Y, 1, function(x) x/1:4))
t(apply(Y, 1, function(x) x/(1:4)))
t(apply(Y, 1, function(x) x/2^(1:4)))
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^1:n))
Y
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^(1:n)))
Y
n
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^(1:n)))
Y
X <- rowSums(Y)
X
n <- 25
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^(1:n)))
rm(list = ls())
gc(verbose = T)
n <- 25
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^(1:n)))
n <- 20
Y <- expand.grid(
rep(
list(c(1,0)),
n)
)
Y <- t(apply(Y, MARGIN = 1, FUN = function(x) x/2^(1:n)))
X <- rowSums(Y)
X[1]
X[2]
X[3]
X[4]
X[5]
X[length(X)]
X <- order(X)
head(X)
?order
X <- rowSums(Y)
X <- sort(X)
X
head(X)
tail(X)
X <- sort(rowSums(Y), decreasing = T)
plot(X)
