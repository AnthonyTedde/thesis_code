o <- outer(1:ncol(Mt), 1:nrow(Mt) , FUN=function(r,c){(r-c) + (1-c)} )
to <- t(o)
subset <- upper.tri(to, diag = T)
Mk <- to * subset
Mk[v,v]
dim_x <- dim_y <- 1:(k + 1) # from 1 to k+1 because we start to time zero nonrandom which equal to zero
o <- outer(dim_x, dim_y, FUN=function(r,c){(r-c) + (1-c)} )
to <- t(o)
subset <- upper.tri(to, diag = T)
Mk <- to * subset
Mk
Mk[v,v]
colnames(Mk) <- paste0("F(", 1:ncol(Mk) - 1, ")")
Mk[vv]
Mk[v,v]
xtable(Mk[1:10, 1:10])
kable
kable(Mk[1:10, 1:10], digits = 0, format = "latex", longtable = TRUE)
kable(Mk[1:10, 1:10], digits = 0, format.args = list("zero.print", FALSE))
kable(Mk[1:10, 1:10], digits = 0, format.args = format(zero.print = FALSE))
kable(Mk[1:10, 1:10], digits = 0, format.args = format(Mk,zero.print = FALSE))
kable(Mk[1:10, 1:10], digits = 0, format.args = format(Mk[1:10, 1:10],zero.print = FALSE))
kable(Mk[1:10, 1:10], digits = 0 )
kable(Mk[1:10, 1:10], digits = 0, format = "latex")
xtable(Mk[1:10, 1:10], digits = 0, format = "latex")
Mk[1, 2]
Mk[2, 1]
is.negative(Mk[2, 1])
Mk[2, 1] < 0
profvis::profvis({for(j in 1:(size + 1))
for(i in 1:j)
Mt[i,j] <- (j-i) + (1-i)})
profvis::profvis({o <- outer(1:ncol(Mt), 1:nrow(Mt) , FUN=function(r,c){(r-c) + (1-c)} )
to <- t(o)
subset <- upper.tri(to, diag = T)
Mk <- to * subset})
1:(size + 1)
profvis::profvis({for(j in 1:(size + 1))
for(i in 1:j)
Mt[i,j] <- (j-i) + (1-i)})
o <- outer(1:ncol(Mt), 1:nrow(Mt) , FUN=function(r,c){(r-c) + (1-c)} )
to <- t(o)
head(to, 5)
to[v,v]
subset <- upper.tri(to, diag = T)
subset[v,v]
profvis::profvis({o <- outer(1:ncol(Mt), 1:nrow(Mt) , FUN=function(r,c){(r-c) + (1-c)} )
to <- t(o)
subset <- upper.tri(to, diag = T)
Mk <- to * subset})
for(j in 1:(size + 1))
for(i in 1:j)
Mt[i,j] <- (j-i) + (1-i)
o <- outer(1:ncol(Mt), 1:nrow(Mt) , FUN=function(r,c){(r-c) + (1-c)} )
to <- t(o)
subset <- upper.tri(to, diag = T)
Mk <- to * subset
dim_x <- dim_y <- 1:(k + 1) # from 1 to k+1 because we start to time zero nonrandom which equal to zero
o <- outer(dim_x, dim_y, FUN=function(r,c){(r-c) + (1-c)} )
to <- t(o)
subset <- upper.tri(to, diag = T)
Mk <- to * subset
colnames(Mk) <- paste0("F(", 1:ncol(Mk) - 1, ")")
xtable(Mk[1:10, 1:10], digits = 0, format = "latex")
xtable(as.character(Mk[1:10, 1:10]), digits = 0, format = "latex")
Mk
as.character(Mk)
Mk_print <- lapply(Mk, as.character)
Mk_print
Mk_print[v,v]
library(plyr)
Mk_print <- adply(Mk, as.character)
adply(Mk, as.character)
Mk
Mk_print <- d_ply(Mk, as.character)
Mk_print <- ddply(Mk, as.character)
colnames(Mk)
Mk_print <- ddply(Mk, colnames(Mk), as.character)
Mk_print <- data.frame(lapply(Mk, as.character))
Mk_print
Mk %>% mutate(as.character) -> Mk_print
library(dplyr)
install.packages("dplyr")
Mk %>% mutate(as.character) -> Mk_print
Mk_print[] <- data.frame(lapply(Mk, as.character))
Mk_print <- as.character(Mk[, ])
Mk_print
class(Mk_print)
Mk_print <- as.character(Mk[,1:301 ])
Mk_print
Mk_print <- apply(Mk, as.character)
Mk_print <- apply(Mk, 1, as.character)
Mk_print
xtable(Mk_print[1:10, 1:10], digits = 0, format = "latex")
Mk_print[v,v]
dim_x <- dim_y <- 1:(k + 1) # from 1 to k+1 because we start to time zero nonrandom which equal to zero
o <- outer(dim_x, dim_y, FUN=function(r,c){(r-c) + (1-c)} )
to <- t(o)
subset <- upper.tri(to, diag = T)
Mk <- to * subset
colnames(Mk) <- paste0("F(", 1:ncol(Mk) - 1, ")")
Mk_print <- apply(Mk, 1, as.character)
Mk_print[v,v]
Mk[v,v]
Mk_print <- apply(Mk, 2, as.character)
Mk_print[v,v]
Mk_print <- apply(Mk, 2, as.character)
Mk.tab
Mk.tab <- xtable(Mk_print[1:10, 1:10], digits = 0, format = "latex")
align(Mk.tab) <- rep("r", 10)
align(Mk.tab) <- rep("r", 11)
Mk.tab
Mk_print <- outer(dim_x, dim_y, FUN = function(i, j){if(j > i) '' else as.character(Mk[i,j])})
Mk_print <- outer(dim_x, dim_y, FUN = function(i, j){if(j > i){''} else {as.character(Mk[i,j])}})
Mk_print[Mk_print == '0'] <- ''
Mk.tab <- xtable(Mk_print[1:10, 1:10], digits = 0, format = "latex")
align(Mk.tab) <- rep("r", 11)
Mk.tab
Mk_print[as.matrix(subset)]
Mk_print[as.matrix(subset), drop = F]
Mk_print[as.matrix(subset), drop = F]
Mk_print <- apply(Mk, 2, as.character)
Mk_print
Mk_print[as.matrix(subset), drop = F]
Mk_print <- apply(Mk, 2, as.character)
Mk_print <- apply(Mk, 2, as.character)
Mk_print[as.matrix(subset), drop = F]
Mk_print[as.matrix(subset), drop = F]
Mk_print <- apply(Mk, 2, as.character)
Mk_print <- apply(Mk, 2, as.character)
Mk_print[, 1:301] <- Mk_print[as.matrix(subset)]
Mk_print[, 1:301] <- Mk_print[as.matrix(subset)[, 1:301]]
length(Mk_print[, 1:301])
length(as.matrix(subset)[, 1:301])
Mk_print[, 1:301]
Mk_print[as.matrix(subset), drop = F]
Mk_print <- apply(Mk, 2, as.character)
Mk_print[as.matrix(subset), drop = F]
Mk_print <- apply(Mk, 2, as.character)
Mk.tab <- xtable(Mk_print[1:10, 1:10], digits = 0, format = "latex")
align(Mk.tab) <- rep("r", 11)
Mk.tab
for(j in 1:(size + 1))
for(i in 1:j)
Mt[i,j] <- (j-i) + (1-i)
for(j in 1:(size+1))
for(i in 1:j)
fi[i, j] <- choose((j-1),
(j-i)) * p^(j-1)
# options
options("scipen" = 999)
options(digits = 7)
# Load libraries
library(ggplot2)
# clear workspace
rm(list = ls())
gc()
p <- 1/2
q <- 1 - p
size <- 300
spread <- 3000
M <- 0
Mt <- fi <- data.frame(matrix(rep(0, (size + 1)^2), nrow = size + 1))
l <- 300
k <- 200
X <- sample(x = c(-1, 1),
size = size,
replace = T,
prob = c(p, q)
X <- sample(x = c(-1, 1),
size = size,
replace = T,
prob = c(p, q)
)
X <- sample(x = c(-1, 1),
size = size,
replace = T,
prob = c(p, q)
)
for(i in 1:size)
M[i + 1] <- sum(X[1:i]) # i + 1 because M[0] from theory is indeed represented by M[1] in this code.
M
M_k <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
png(filename = 'SymmetricRandomWalk.png')
plot(M_k,
type = 'l')
dev.off()
for(j in 1:(size + 1))
for(i in 1:j)
Mt[i,j] <- (j-i) + (1-i)
dim_x <- dim_y <- 1:(size + 1)
dim_x <- dim_y <- 1:(size + 1)
o <- outer(dim_x,
dim_y,
FUN=function(r,c){(r-c) + (1-c)} )
v <- 1:10
to <- t(o)
subset <- upper.tri(to, diag = T)
Mk <- to * subset
Mk[v,v]
for(j in 1:(size+1))
for(i in 1:j)
fi[i, j] <- choose((j-1),
(j-i)) * p^(j-1)
profvis::profvis({# Usual wrong way:
# Profiling give 1200 Ms
for(j in 1:(size+1))
for(i in 1:j)
fi[i, j] <- choose((j-1),
(j-i)) * p^(j-1)})
o <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
for(j in 1:(size+1))
for(i in 1:j)
fi[i, j] <- choose((j-1),
(j-i)) * p^(j-1)
o == fi
sum(o != fi)
profvis::profvis({for(j in 1:(size+1))
for(i in 1:j)
fi[i, j] <- choose((j-1),
(j-i)) * p^(j-1)})
o <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
fi <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
fromto <- 1:size + 1
to <- size + 1
plot(Mt[fromto, to],
fi[fromto, to],
type = 'l',
xlim = c(-75, 75))
Mt[fromto, to]
size + 1
fi[fromto, to]
Mt[fromto, to]
fi[150]
fi
fi[150, 301]
length(Mk)
ncol(Mk)
lastToss <- ncol(Mk)
range <- 1:ncol(Mk)
lastToss <- ncol(Mk)
plot(Mt[range, lastToss],
fi[range, lastToss],
type = 'l',
xlim = c(-75, 75))
distributionSymRanWal <- cbind(
Mt[range, lastToss],
fi[range, lastToss]
)
distributionSymRanWal
names(distributionSymRanWal)
names(distributionSymRanWal) <- c("Value", "Frequency")
ggplot(distributionSymRanWal, aes(Value, Frequency)) +
geom_line()
distributionSymRanWal <- data.frame(
Value = Mt[range, lastToss],
Frequency = fi[range, lastToss]
)
distributionSymRanWal
ggplot(distributionSymRanWal, aes(Value, Frequency)) +
geom_line()
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line()
ggplot(data = distributionSymRanWal, aes(Value, Frequency))
ggplot(data = df_Mk, aes(x, y)) +
geom_line() +
dev.off()
dev.off()
dev.off()
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line()
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100))
min(distributionSymRanWal[, 'Value'])
limitX <- c(min(distributionSymRanWal[, 'Value']),
max(distributionSymRanWal[, 'Value']))
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = limitX)
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100))
# options
options("scipen" = 999)
options(digits = 7)
# Load libraries
library(ggplot2)
# clear workspace
rm(list = ls())
gc()
################################################################################
# Variables names
################################################################################
# p: Probability of Head
# q: Probability of Tail (1 - p)
# size: Number of periods for the Random Walk (start at 0)
# spread: Number of generated Random Walks
# X: Random variable which take value in {-1, 1}
#   -> 1  for each head with probability p
#   -> -1 for each tail with probability q
# M: symmetric random Walk -> construction based on X
# Mt: Random variable equiped with a filtration F(t)
# fi: Distribution of Mt
# l and k: both are time in the interval: [1, size + 1]
#
################################################################################
# Create a 300 steps random walk
################################################################################
##
# Initialisation
##
# Probability measure:
p <- 1/2
q <- 1 - p
size <- 300
spread <- 3000
M <- 0
###
# Mt and fi are dataframe with size = (size + 1) * (size + 1)
# All value inside Mt and fi are zero.
# check ate Initialisation section for size value.
###
Mt <- fi <- data.frame(matrix(rep(0, (size + 1)^2), nrow = size + 1))
l <- 300
k <- 200
##
# Generation
##
X <- sample(x = c(-1, 1),
size = size,
replace = T,
prob = c(p, q)
)
# Following lines must be changed into apply type function:
for(i in 1:size)
M[i + 1] <- sum(X[1:i]) # i + 1 because M[0] from theory is indeed represented by M[1] in this code.
# Same result with apply type function:
M_k <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
##
# Check by plot
##
png(filename = 'SymmetricRandomWalk.png')
plot(M_k,
type = 'l')
dev.off()
################################################################################
# Creation of a 300 steps random walk
################################################################################
##
# Construction of the theoretical Random Variable M based on the filtration F(t)
# See document "randomWalkDistributionAnalysis.jgp"
##
# Usual wrong way:
# Profiling give 1200 Ms
for(j in 1:(size + 1))
for(i in 1:j)
Mt[i,j] <- (j-i) + (1-i)
# Functional Way:
# No information from profiler: too fast
dim_x <- dim_y <- 1:(size + 1)
o <- outer(dim_x,
dim_y,
FUN=function(r,c){(r-c) + (1-c)} )
to <- t(o)
subset <- upper.tri(to, diag = T)
Mk <- to * subset
##
# Construction of the distribution of the theoretical random variable
##
# Usual wrong way:
# Profiling give 1200 Ms
for(j in 1:(size+1))
for(i in 1:j)
fi[i, j] <- choose((j-1),
(j-i)) * p^(j-1)
# Same results following funcional way
o <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
##
# Graph of the Theoretical distribution
##
png(filename = 'SymmRandWalkTheoretiaclDistrib.png')
range <- 1:ncol(Mk)
lastToss <- ncol(Mk)
# Using plot
plot(Mt[range, lastToss],
fi[range, lastToss],
type = 'l',
xlim = c(-75, 75))
distributionSymRanWal <- data.frame(
Value = Mt[range, lastToss],
Frequency = fi[range, lastToss]
)
dev.off()
dev.off()
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100))
library(ggplot2)
library(ggplot)
version
install.packages("ggplot2")
library(ggplot)
library(ggplot2)
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100))
plot(Mt[range, lastToss],
fi[range, lastToss],
type = 'l',
xlim = c(-75, 75))
# Probability measure:
p <- 1/2
q <- 1 - p
size <- 300
spread <- 3000
M <- 0
###
# Mt and fi are dataframe with size = (size + 1) * (size + 1)
# All value inside Mt and fi are zero.
# check ate Initialisation section for size value.
###
Mt <- fi <- data.frame(matrix(rep(0, (size + 1)^2), nrow = size + 1))
l <- 300
k <- 200
##
# Generation
##
X <- sample(x = c(-1, 1),
size = size,
replace = T,
prob = c(p, q)
)
# Following lines must be changed into apply type function:
for(i in 1:size)
M[i + 1] <- sum(X[1:i]) # i + 1 because M[0] from theory is indeed represented by M[1] in this code.
# Same result with apply type function:
M_k <- c(0,
sapply(seq_along(X), function(x){sum(X[1:x])}))
##
# Check by plot
##
png(filename = 'SymmetricRandomWalk.png')
plot(M_k,
type = 'l')
dev.off()
################################################################################
# Creation of a 300 steps random walk
################################################################################
##
# Construction of the theoretical Random Variable M based on the filtration F(t)
# See document "randomWalkDistributionAnalysis.jgp"
##
# Usual wrong way:
# Profiling give 1200 Ms
for(j in 1:(size + 1))
for(i in 1:j)
Mt[i,j] <- (j-i) + (1-i)
# Functional Way:
# No information from profiler: too fast
dim_x <- dim_y <- 1:(size + 1)
o <- outer(dim_x,
dim_y,
FUN=function(r,c){(r-c) + (1-c)} )
to <- t(o)
subset <- upper.tri(to, diag = T)
Mk <- to * subset
##
# Construction of the distribution of the theoretical random variable
##
# Usual wrong way:
# Profiling give 1200 Ms
for(j in 1:(size+1))
for(i in 1:j)
fi[i, j] <- choose((j-1),
(j-i)) * p^(j-1)
# Same results following funcional way
o <- outer(dim_x,
dim_y,
FUN = function(i, j){choose((j-1), (j-i)) * p^(j-1)})
##
# Graph of the Theoretical distribution
##
png(filename = 'SymmRandWalkTheoretiaclDistrib.png')
range <- 1:ncol(Mk)
lastToss <- ncol(Mk)
# Using plot
plot(Mt[range, lastToss],
fi[range, lastToss],
type = 'l',
xlim = c(-75, 75))
# Using ggplot
# data.frame which map distribution and random variable:
distributionSymRanWal <- data.frame(
Value = Mt[range, lastToss],
Frequency = fi[range, lastToss]
)
dev.off()
library(ggplot2)
ggplot(data = distributionSymRanWal, aes(Value, Frequency)) +
geom_line() +
scale_x_continuous(limits = c(-100, 100))
