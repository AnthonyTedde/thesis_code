?seq
domain <- seq(from = 0,
to = 1,
by = 0.000001)
domain
head(domain)
?head
tail(domain)
length(domain)
?Uniform
punif(domain)
plot(punif(domain))
plot(punif(domain))
quit
plot(1:5)
quit
quit
quit
?plot
plot(1:5)
plot(punif(1:60))
plot(punif(domain))
punif(1:5)
punif(1:75)
punif(555)
plot(punif(0:400))
punif(0)
dunif(0:400)
dunif(3)
?dunif
vectorOfQuantile <- seq(from = 0,
to = 1,
by = .25)
vectorOfQuantile
punif(q = vectorOfQuantile,
min = 0,
max = 1)
dunif(x = vectorOfQuantile)
dunif(x = 1:5)
dunif(x = vectorOfQuantile)
domain <- seq(from = 0,
to = 1,
by = 0.01)
plot(punif(domain))
plot(dunif(domain))
domain
punif(domain)
plot(domain, punif(domain))
plot(domain, dunif(domain))
plot(domain, punif(domain))
?plot
plot(x = domain,
y = punif(domain),
type = 'l')
plot(x = domain,
y = punif(domain),
type = 'l')
plot(domain, dunif(domain))
mux <- .8 - .4
punif(x = .8) - punif(x = .4)
punif(x = .8)
punif(.8) - punif(.4)
mux
dt <- 0.4 * 0.8
leftHandBound <- dunif(0.4)
integral <- df * leftHandBound
leftHandBound
dt
dt <- 0.4 * 0.8
leftHandBound <- dunif(0.4)
integral <- df * leftHandBound
typeof(leftHandBound)
typeof(dt)
dt
dt + 1
dt * 1
dt
dt <- 0.8 - 0.4
integral <- dt * leftHandBound
integral
W <- seq(from = 0,
to = 1,
by = .0001)
mean(w)
mean(W)
?mean
hean(W)
head(W)
?Uniform
head(dunif(W))
punif(dunif(W))
dunif(W)
punif(W)
length(W)
punif(W)[length(W) / 2]
length(W)
length(W)/2
0.5* (punif(W)[floor(length(W) / 2)] + punif(W)[ceiling(length(W) / 2)])
punif(W)[ceiling(length(W) / 2)
]
(punif(W)[floor(length(W) / 2)]
]
(punif(W)[floor(length(W) / 2)])
punif(W)[lenght(W) / 2]
punif(W)[length(W) / 2]
p <- 1/2
q <- 1 - p
?binom
?binomial
?binom.test
?dbinom
rbinom(2,100)
rbinom(2,100, 0.5)
rbinom(1000,2, 0.5)
rbinom(1000,1, 0.5)
y = list()
rbinom(1000,1, 0.5)
y
y[[1]] <- 1:3
y
y[1]
y[[1]]
y[1] <- 1:5
y
str(y)
y = list()
y[[1]] <- rbinom(n = 1000,
size = 1,
prob = p)
y
str(y)
?for
fkjlsd
?loop
??loop
y = list()
n <- 3000
for(i in n)
y[[i]] <- rbinom(n = 1000,
size = 1,
prob = p)
str(y)
head(y)
rbinom(n = 1000, size = 1, prob = p)
rbinom(n = 1000, size = 1, prob = p)
tail(y)
tail(y)
head(str(y))
y[[1]]
y[[6]]
y[[2999]]
y[[99999]]
n <- 1:3000
y = list()
for(i in n){
y[[i]] <- rbinom(n = 1000,
size = 1,
prob = p)
}
head(str(y))
Y = list()
for(i in n){
Y[[i]] <- rbinom(n = 1000,
size = 1,
prob = p)
}
x <- vector()
x
x[1] <- toto
x[1] <- 'toto'
x
YPrime <- list()
YPrime <- list()
for(i in n)
for(j in 1:1000)
YPrime[[i]][j] <- Y[[i]][j] / 2^j
YPrime <- y
for(i in n)
for(j in 1:1000)
YPrime[[i]][j] <- Y[[i]][j] / 2^j
x <- vector()
x <- vector()
for(i in n)
x[i] <- sum(YPrime[[i]])
x
y[[2]]
head(y[[2]])
head(x)
head(y[[1]])
y[[2]][1]
head(YPrime)
head(YPrime[[2]])
head(Y[[2]])
head(X[[2]])
head(X[2])
head(X[2])
x
head(x[2])
head(y[[2]])
head(Y[[2]])
head(Y[[996]])
mean(Y[[996]])
X <- vector()
for(i in n)
X[i] <- sum(YPrime[[i]])
n[last]
n[length(n)]
ProbX <- 1 / 2 ^ n[length(n)]
ProbX
1/2^3000
?install.packages
install.packages()
install.package
install.packages("Rmpfr")
library(Rmpfr)
mpfr(ProbX)
?mpfr
mpfr(ProbX, 53)
mpfr(1/2^3000,53)
mpfr(1/2^3000,100)
ProbX <- 1 / 2 ^ n[length(n)]
ProbX
1/9999999999999999
1/99999999999999999999999999999999999999999999999
1/99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
2^3000
2^3000 * 2000
1/2^3000 * 2000
1/2^30 * 2000
1/2^30
1/2^300
W <- seq(from = 0,
to = 1,
by = .0001)
mean(W)
punif(W)[length(W) / 2]
length(n)
n <- 1:3000
Y = list()
for(i in n){
Y[[i]] <- rbinom(n = s,
size = 1,
prob = p)
}
s <- 1000
Y = list()
for(i in n){
Y[[i]] <- rbinom(n = s,
size = 1,
prob = p)
}
YPrime <- y
for(i in n)
for(j in 1:1000)
YPrime[[i]][j] <- Y[[i]][j] / 2^j
n <- 1:30
Y = list()
for(i in n){
Y[[i]] <- rbinom(n = s,
size = 1,
prob = p)
}
YPrime <- y
for(i in n)
for(j in 1:n)
YPrime[[i]][j] <- Y[[i]][j] / 2^j
warnings()
YPrime <- y
for(i in n)
for(j in 1:s)
YPrime[[i]][j] <- Y[[i]][j] / 2^j
X <- vector()
for(i in n)
X[i] <- sum(YPrime[[i]])
X
ProbX <- 1 / 2 ^ n[length(n)]
ProbX
2^30
#################################################################
# Example 1.2.5: Another random variable uniformly distributed.
################################################################
# W random variables included various value from 0 to one.
# All UNIFORMALY distributed.
W <- seq(from = 0,
to = 1,
by = .0001)
# Expected value of random variable W:
# n^-1 * sum(wi) or mean():
mean(W)
# using UNIFORM distribution.
punif(W)[length(W) / 2]
#
# Define the probability measure p & q
p <- 1/2
q <- 1 - p
# number of exeriments: length(n)
n <- 1:2
# Sample size:
s <- 1000
#
# Y should be constructed according to some random experiment.
Y = list()
for(i in n){
Y[[i]] <- rbinom(n = s,
size = 1,
prob = p)
}
# According to Y, construction of X:
# X should be a random variable construct upon a vector
# Transformation of Y
YPrime <- y
for(i in n)
for(j in 1:s)
YPrime[[i]][j] <- Y[[i]][j] / 2^j
X <- vector()
for(i in n)
X[i] <- sum(YPrime[[i]])
# Probability that the value of X fall between 4/3000 and 5/3000:
ProbX <- 1 / 2 ^ n[length(n)]
ProbX
2^1000
# number of exeriments: length(n)
n <- 1:100000
# Sample size:
s <- 100
Y = list()
for(i in n){
Y[[i]] <- rbinom(n = s,
size = 1,
prob = p)
}
YPrime <- y
for(i in n)
for(j in 1:s)
YPrime[[i]][j] <- Y[[i]][j] / 2^j
y[[1]]
y[[2]]
y[[100000]]
Y[[100000]]
YPrime <- Y
for(i in n)
for(j in 1:s)
YPrime[[i]][j] <- Y[[i]][j] / 2^j
X <- vector()
for(i in n)
X[i] <- sum(YPrime[[i]])
ProbX <- 1 / 2 ^ s
ProbX
mean(X[X >= (1/2^100) & X <= (2/2^100)])
X[X >= (1/2^100) & X <= (2/2^100)]
X[1]
X[X == 0.699192]
X[X = 0.699192]
X[X > 0.68]
X[X >= (1/2^100)]
X[X >= (1/2^100) & X <= (2/2^100)]
expe <- 1:100000
expe <- 100000
n <- 100
expe <- 100000
n <- 100
Y = list()
for(i in 1:expe){
Y[[i]] <- rbinom(n = n,
size = 1,
prob = p)
}
YPrime <- Y
for(i in 1:expe)
for(j in 1:n)
YPrime[[i]][j] <- Y[[i]][j] / 2^j
X <- vector()
for(i in 1:expe)
X[i] <- sum(YPrime[[i]])
ProbX <- 1 / 2 ^ n
ProbX
2^100
2/2^100
300000/2^100
300000000000000000/2^100
300000000000000000000000000000000/2^100
300000000000000000000000000000/2^100
k <- 300000000000000000000000000000/2^100
X[X < k]
300000000000000000000000000000/2^100
3e20
3e20 / 1^100
3e20 / 2^100
3e30 / 2^100
3e29 / 2^100
(3e29 - 0)/2^n
length(X)
length(X[X < 3e29/2^n]) / length(X)
probI <- (3e29 - 3e15)/2^n
probI
probI <- (3e29 - 3e15)/2^n
probI
(3e29 - 3e15)/2^n
(3e29 - 3e15)
3e28
3e29 - 3e28
(3e29 - 3e28)/2^n
probI <- (3e29 - 3e28)/2^n
probI
length(X[x<3e28/2^n & X < 3e29/2^n]) / length(X)
X[x<3e28/2^n & X < 3e29/2^n]
length(X)
length(X[x > 3e28/2^n & X < 3e29/2^n])
length(X[x > 3e28/2^n && X < 3e29/2^n])
length(X[x > 3e28/2^n & X < 3e29/2^n])
length(X[X > 3e28/2^n & X < 3e29/2^n])
length(X[X > 3e28/2^n & X < 3e29/2^n]) / length(X)
probI
?binom
?binomial
?base::binomial
??binom
rbinom(n = 300, size = 1, prob = 0.5)
rbinom(n = 300, size = c(-1,1), prob = 0.5)
?seq
?random
?rand
?Uniform
?sample
sample(x = c(-1, 0), replace = T, prob = 0.5, size = 300)
sample(x = c(-1, 0), replace = T, prob = c(0.5, 0.5), size = 300)
p <- 1/2
q <- 1 - p
X <- sample(x = c(-1, 1),
replace = T,
prob = c(p, q),
size = 300)
size <- 300
X
sum(X)
X[1:4]
for(i in 1:size)
M[i] <- sum(X[1:i])
M <- X[0]
for(i in 1:size)
M[i] <- sum(X[1:i])
M
plot(M)
plot(M, line)
?plot
plot(M, type = 'l')
p <- 1/2
q <- 1 - p
size <- 300
X <- sample(x = c(-1, 1),
replace = T,
prob = c(p, q),
size = size)
M <- X[0]
for(i in 1:size)
M[i] <- sum(X[1:i])
png(filename = 'SymmetricRandomWalk.png')
plot(M,
type = 'l')
dev.off()
Xs <- data.frame()
for(i in 1:spread)
Xs[i, ] <- sample(x = c(-1, 1),
replace = T,
prob = c(p, q),
size = size)
spread <- 3000
for(i in 1:spread)
Xs[i, ] <- sample(x = c(-1, 1),
replace = T,
prob = c(p, q),
size = size)
warings()
warnings()
Xs
?data.frame
Xs <- list()
for(i in 1:spread)
Xs[[i]] <- sample(x = c(-1, 1),
replace = T,
prob = c(p, q),
size = size)
